# Module `src.steam_library_analyzer`

## Functions

` def calculate_similarity_and_rank(self, games_data,
combination_method='average') `

     Expand source code
    
    
    def calculate_similarity_and_rank(self, games_data, combination_method='average'):
        """–í—ã—á–∏—Å–ª—è–µ—Ç –∫–æ—Å–∏–Ω—É—Å–Ω—É—é —Å—Ö–æ–∂–µ—Å—Ç—å –∏ —Ä–∞–Ω–∂–∏—Ä—É–µ—Ç –∏–≥—Ä—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –≤–µ–∫—Ç–æ—Ä–æ–≤."""
        if not games_data:
            return []
    
        print(f"\n--- ‚öôÔ∏è –ú–µ—Ç–æ–¥ calculate_similarity_and_rank: {combination_method} ---")
    
        train_vectors = self.model.transform(self.train_df)
    
        new_df = pd.DataFrame(games_data)
        new_df['short_description_clean'] = new_df['short_description'].apply(clean_text)
        new_df['steam_id'] = [game.get('appid') for game in games_data]
    
        game_vectors = self.model.transform(new_df)
    
        if combination_method == 'average':
            combined_game_vector = np.mean(game_vectors, axis=0).reshape(1, -1)
            method_name = "–û–±—ã—á–Ω–æ–µ —É—Å—Ä–µ–¥–Ω–µ–Ω–∏–µ –≤–µ–∫—Ç–æ—Ä–æ–≤"
        elif combination_method == 'sum':
            combined_game_vector = np.sum(game_vectors, axis=0).reshape(1, -1)
            method_name = "–û–±—ã—á–Ω–æ–µ —Å—É–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–µ–∫—Ç–æ—Ä–æ–≤"
        else:
            raise ValueError(f"‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –º–µ—Ç–æ–¥ –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏—è: {combination_method}")
    
        similarities = cosine_similarity(combined_game_vector, train_vectors)
        game_similarities = similarities[0]
        ranked_indices = np.argsort(game_similarities)[::-1]
    
        game_recommendations = []
    
        input_game_names_processed = {process_game_name(game_data.get('name')) for game_data in games_data if 'name' in game_data}
        print(f"üêû input_game_names_processed: {input_game_names_processed}")
    
        for j in ranked_indices:
            recommended_game = self.train_df.iloc[j]
            recommended_game_name = recommended_game['name']
            recommended_game_name_processed = process_game_name(recommended_game_name)
    
            print(f"ü§î –†–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–µ–º —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—é: –ù–∞–∑–≤–∞–Ω–∏–µ: {recommended_game_name}, Processed Name: {recommended_game_name_processed}")
    
            if recommended_game_name_processed in input_game_names_processed:
                print(f"üö´ –ò—Å–∫–ª—é—á–µ–Ω–∞ –∏–≥—Ä–∞: {recommended_game_name} (processed name: {recommended_game_name_processed}) —Ç–∞–∫ –∫–∞–∫ –æ–Ω–∞ –µ—Å—Ç—å –≤–æ –≤—Ö–æ–¥–Ω–æ–π –≥—Ä—É–ø–ø–µ.")
                continue
            else:
                print(f"üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–º–µ–Ω–∏: '{recommended_game_name_processed}' –Ω–µ –≤ '{input_game_names_processed}' - –∏–≥—Ä–∞ –ù–ï –∏–∑ –≤—Ö–æ–¥–Ω–æ–π –≥—Ä—É–ø–ø—ã.")
    
            estimated_owners = recommended_game['estimated_owners']
            positive = recommended_game['positive']
            negative = recommended_game['negative']
    
            if estimated_owners == 0:
                print(f"üö´ –ò—Å–∫–ª—é—á–µ–Ω–∞ –∏–≥—Ä–∞: {recommended_game_name} (steam_id: {recommended_game.name}) –∏–∑-–∑–∞ estimated_owners == 0.")
                continue
    
            if isinstance(positive, (int, float)) and isinstance(negative, (int, float)):
                total_reviews = positive + negative
                if total_reviews > 0:
                    positive_ratio = positive / total_reviews
                    if positive_ratio < 0.7:
                        print(f"üö´ –ò—Å–∫–ª—é—á–µ–Ω–∞ –∏–≥—Ä–∞: {recommended_game_name} (steam_id: {recommended_game.name}) –∏–∑-–∑–∞ positive_ratio < 0.7 ({positive_ratio:.2f}).")
                        continue
    
            if len(game_recommendations) < 10:
                game_recommendations.append(
                    {
                        "name": recommended_game_name,
                        "estimated_owners": estimated_owners,
                        "steam_id": recommended_game.name,
                        "similarity_score": game_similarities[j]
                    }
                )
            if len(game_recommendations) >= 10:
                break
    
        scores = [d['similarity_score'] for d in game_recommendations]
        median_similarity = np.median(scores) if scores else 0
    
        ranked_game_group = {
            "game_data": {"name": f"–ì—Ä—É–ø–ø–∞ –∏–≥—Ä ({method_name})", "appid": f"group_{combination_method}"},
            "recommendations": game_recommendations,
            "median_similarity": median_similarity,
            "combination_method": method_name
        }
        return ranked_game_group

–í—ã—á–∏—Å–ª—è–µ—Ç –∫–æ—Å–∏–Ω—É—Å–Ω—É—é —Å—Ö–æ–∂–µ—Å—Ç—å –∏ —Ä–∞–Ω–∂–∏—Ä—É–µ—Ç –∏–≥—Ä—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö
–≤–µ–∫—Ç–æ—Ä–æ–≤.

` def load_dataframe(df_path) `

     Expand source code
    
    
    def load_dataframe(df_path):
        """–ó–∞–≥—Ä—É–∂–∞–µ—Ç DataFrame –∏–∑ JSON —Ñ–∞–π–ª–∞ –∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∏–Ω–¥–µ–∫—Å."""
        df = pd.read_json(df_path)
        if 'steam_id' in df.index.names:
            df['steam_id'] = df.index
            df = df.reset_index(drop=True)
            df = df.set_index('steam_id')
        else:
            if df.index.is_numeric():
                df['steam_id'] = df.index.astype(int)
                df = df.reset_index(drop=True)
                df = df.set_index('steam_id')
        return df

–ó–∞–≥—Ä—É–∂–∞–µ—Ç DataFrame –∏–∑ JSON —Ñ–∞–π–ª–∞ –∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∏–Ω–¥–µ–∫—Å.

` def load_model(model_path) `

     Expand source code
    
    
    def load_model(model_path):
        """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ –æ–±—É—á–µ–Ω–Ω—É—é –º–æ–¥–µ–ª—å –∏–∑ —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞."""
        with open(model_path, 'rb') as f:
            return pickle.load(f)

–ó–∞–≥—Ä—É–∂–∞–µ—Ç –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ –æ–±—É—á–µ–Ω–Ω—É—é –º–æ–¥–µ–ª—å –∏–∑ —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞.

` def main() `

     Expand source code
    
    
    def main():
        """–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∏–≥—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è Steam –∏–ª–∏ –æ–¥–∏–Ω–æ—á–Ω–æ–π –∏–≥—Ä—ã."""
        analyzer = LibraryAnalyzer()
        parser = argparse.ArgumentParser(description="–ê–Ω–∞–ª–∏–∑ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∏–≥—Ä Steam –∏–ª–∏ –æ–¥–∏–Ω–æ—á–Ω–æ–π –∏–≥—Ä—ã –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π.")
        group = parser.add_mutually_exclusive_group(required=True) # –ì—Ä—É–ø–ø–∞ –¥–ª—è –≤–∑–∞–∏–º–æ–∏—Å–∫–ª—é—á–∞—é—â–∏—Ö –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤
    
        group.add_argument('--library', action='store_true', help='–ó–∞–ø—É—Å—Ç–∏—Ç—å –∞–Ω–∞–ª–∏–∑ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∏–≥—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è Steam (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç STEAM_USER_URL –∏–∑ .env –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é).')
        group.add_argument('--game', type=str, help='–ó–∞–ø—É—Å—Ç–∏—Ç—å –∞–Ω–∞–ª–∏–∑ –¥–ª—è –æ–¥–∏–Ω–æ—á–Ω–æ–π –∏–≥—Ä—ã. –£–∫–∞–∂–∏—Ç–µ steamid, –Ω–∞–∑–≤–∞–Ω–∏–µ –∏–≥—Ä—ã –∏–ª–∏ —Å—Å—ã–ª–∫—É –Ω–∞ –∏–≥—Ä—É.')
    
        args = parser.parse_args()
    
        if args.library:
            print("–í—ã–±—Ä–∞–Ω —Ä–µ–∂–∏–º –∞–Ω–∞–ª–∏–∑–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏.")
            analyzer.run_analysis(STEAM_USER_URL) # –ò—Å–ø–æ–ª—å–∑—É–µ–º STEAM_USER_URL –∏–∑ .env
        elif args.game:
            print(f"–í—ã–±—Ä–∞–Ω —Ä–µ–∂–∏–º –∞–Ω–∞–ª–∏–∑–∞ –æ–¥–∏–Ω–æ—á–Ω–æ–π –∏–≥—Ä—ã –¥–ª—è: '{args.game}'.")
            game_recommendations = analyzer.analyze_single_game(args.game)
            if game_recommendations:
                print(f"\n--- üèÜ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –¥–ª—è –∏–≥—Ä—ã '{args.game}' ---")
                recommendations = game_recommendations.get("recommendations")
                median_similarity = game_recommendations.get("median_similarity")
                combination_method_name = game_recommendations.get("combination_method")
    
                print(f"\n‚ú® –ú–µ—Ç–æ–¥ –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏—è: {combination_method_name}")
                print(f"‚≠ê –ú–µ–¥–∏–∞–Ω–∞ similarity score: {median_similarity:.4f}")
                print("‚úÖ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:")
                for rec in recommendations:
                    print(f"  - üéÆ –ù–∞–∑–≤–∞–Ω–∏–µ: {rec['name']}, üë§ –í–ª–∞–¥–µ–ª—å—Ü—ã: {rec['estimated_owners']}, üÜî Steam ID: {rec['steam_id']}, üíØ –°—Ö–æ–∂–µ—Å—Ç—å: {rec['similarity_score']:.4f}")
                print("---")
            else:
                print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–π –∏–≥—Ä—ã.")

–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∏–≥—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è Steam –∏–ª–∏
–æ–¥–∏–Ω–æ—á–Ω–æ–π –∏–≥—Ä—ã.

` def process_game_name(name) `

     Expand source code
    
    
    def process_game_name(name):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –Ω–∞–∑–≤–∞–Ω–∏–µ –∏–≥—Ä—ã –¥–ª—è —Ü–µ–ª–µ–π —Å—Ä–∞–≤–Ω–µ–Ω–∏—è."""
        if not isinstance(name, str):
            return ""
        name_lower = name.lower()
        name_latin_only = re.sub(r'[^a-z0-9\s]', '', name_lower)
        return name_latin_only

–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –Ω–∞–∑–≤–∞–Ω–∏–µ –∏–≥—Ä—ã –¥–ª—è —Ü–µ–ª–µ–π —Å—Ä–∞–≤–Ω–µ–Ω–∏—è.

## Classes

` class LibraryAnalyzer `

     Expand source code
    
    
    class LibraryAnalyzer:
        """
        –ö–ª–∞—Å—Å –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∏–≥—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è Steam –∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π.
        """
        process_game_name = staticmethod(process_game_name)
        calculate_similarity_and_rank = calculate_similarity_and_rank
    
        def __init__(self):
            """
            –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç LibraryAnalyzer.
            """
            self.api_parser = ApiParser()
            self.model = load_model(MODEL_PATH)
            self.train_df = load_dataframe(DF_PROCESSED_JSON_PATH)
            self.train_df['short_description_clean'] = self.train_df['short_description'].apply(clean_text)
            self.data_cleaner = DataCleaner()
    
        def get_games_data_from_dataset(self, games):
            """–ò–∑–≤–ª–µ–∫–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –æ–± –∏–≥—Ä–∞—Ö –∏–∑ –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–≥–æ –¥–∞—Ç–∞—Å–µ—Ç–∞."""
            found_games = []
            not_found_games = []
            for game in games:
                app_id = game.get("appid")
                if app_id is not None and app_id in self.train_df.index:
                  found_games.append(self.train_df.loc[app_id])
                else:
                    not_found_games.append(game)
            return found_games, not_found_games
    
        def get_games_data_from_api(self, not_found_games):
            """–ü–æ–ª—É—á–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –æ–± –∏–≥—Ä–∞—Ö –∏–∑ Steam API –∏ Steam Spy API."""
            games_data = []
            if not not_found_games:
                return games_data
            for game in not_found_games:
                app_id = game.get('appid')
                if app_id:
                    steam_web_api_response = self.api_parser.steam_web_api_client.make_request(
                        request_name="get_app_details",
                        request_params={"appids": app_id}
                    )
    
                    app_data = None
                    if steam_web_api_response['error'] is None and steam_web_api_response['response_json']:
                        app_data = steam_web_api_response['response_json'].get(str(app_id), {}).get('data')
    
                    if app_data:
                        categories = app_data.get("categories", [])
                        if not isinstance(categories, list):
                            categories = []
                        parsed_data = {
                            "name": app_data.get("name", "placeholder"),
                            "release_date": app_data.get("release_date", {}).get("date", "placeholder"),
                            "required_age": app_data.get("required_age", "placeholder"),
                            "price": app_data.get("price_overview", {}).get("final_formatted", "placeholder"),
                            "dlc_count": len(app_data.get("dlc", [])) if isinstance(app_data.get("dlc"), list) else 0,
                            "detailed_description": app_data.get("detailed_description", "placeholder"),
                            "about_the_game": app_data.get("about_the_game", "placeholder"),
                            "short_description": app_data.get("short_description", "placeholder"),
                            "reviews": app_data.get("reviews", "placeholder"),
                            "header_image": app_data.get("header_image", "placeholder"),
                            "website": app_data.get("website", "placeholder"),
                            "support_url": app_data.get("support_info", {}).get("url", "placeholder"),
                            "support_email": app_data.get("support_info", {}).get("email", "placeholder"),
                            "windows": app_data.get("platforms", {}).get("windows", "placeholder"),
                            "mac": app_data.get("platforms", {}).get("mac", "placeholder"),
                            "linux": app_data.get("platforms", {}).get("linux", "placeholder"),
                            "metacritic_score": app_data.get("metacritic", {}).get("score", "placeholder"),
                            "metacritic_url": app_data.get("metacritic", {}).get("url", "placeholder"),
                            "achievements": app_data.get("achievements", {}).get("total", "placeholder"),
                            "recommendations": app_data.get("recommendations", {}).get("total", "placeholder"),
                            "notes": "placeholder",
                            "supported_languages": app_data.get("supported_languages", "placeholder"),
                            "full_audio_languages": app_data.get("full_audio_languages", "placeholder"),
                            "packages": app_data.get("packages", "placeholder"),
                            "developers": app_data.get("developers", "placeholder"),
                            "publishers": app_data.get("publishers", "placeholder"),
                            "categories": [cat.get("description", "placeholder") for cat in categories],
                            "genres": [genre.get("description", "placeholder") for genre in app_data.get("genres", [])],
                            "screenshots": [ss.get("path_thumbnail", "placeholder") for ss in app_data.get("screenshots", [])],
                            "movies": [m.get("webm", {}).get("480", "placeholder") for m in app_data.get("movies", [])],
                            "user_score": "placeholder",
                            "score_rank": "placeholder",
                            "positive": "placeholder",
                            "negative": "placeholder",
                            "estimated_owners": app_data.get("estimated_owners", np.nan),
                            "average_playtime_forever": "placeholder",
                            "average_playtime_2weeks": "placeholder",
                            "median_playtime_forever": "placeholder",
                            "median_playtime_2weeks": "placeholder",
                            "peak_ccu": "placeholder",
                            "all_tags": [cat.get("description", "placeholder") for cat in categories],
                            "steam_id": app_id
                        }
                        if pd.isna(parsed_data["estimated_owners"]):
                            parsed_data["estimated_owners"] = 100000
    
                        cleaned_data = self.data_cleaner.clean_data(pd.DataFrame([parsed_data]))
                        if cleaned_data.shape[0] > 0:
                            games_data.append(cleaned_data.to_dict('records')[0])
                    else:
                        steamspy_api_response = self.api_parser.steamspy_api_client.make_request(
                            request_name="get_app_details",
                            request_params={"appid": app_id}
                        )
                        if steamspy_api_response['error'] is None and steamspy_api_response['response_json']:
                            app_data = steamspy_api_response['response_json']
                            categories = app_data.get("categories", [])
                            if not isinstance(categories, list):
                                categories = []
    
                            parsed_data = {
                                "name": app_data.get("name", "placeholder"),
                                "release_date": "placeholder",
                                "required_age": "placeholder",
                                "price": "placeholder",
                                "dlc_count": "placeholder",
                                "detailed_description": "placeholder",
                                "about_the_game": "placeholder",
                                "short_description": "placeholder",
                                "reviews": "placeholder",
                                "header_image": "placeholder",
                                "website": "placeholder",
                                "support_url": "placeholder",
                                "support_email": "placeholder",
                                "windows": "placeholder",
                                "mac": "placeholder",
                                "linux": "placeholder",
                                "metacritic_score": app_data.get("metacritic", "placeholder"),
                                "metacritic_url": "placeholder",
                                "achievements": "placeholder",
                                "recommendations": "placeholder",
                                "notes": "placeholder",
                                "supported_languages": "placeholder",
                                "full_audio_languages": "placeholder",
                                "packages": "placeholder",
                                "developers": "placeholder",
                                "publishers": "placeholder",
                                "categories": "placeholder",
                                "genres": "placeholder",
                                "screenshots": "placeholder",
                                "movies": "placeholder",
                                "user_score": "placeholder",
                                "score_rank": "placeholder",
                                "positive": app_data.get("positive", "placeholder"),
                                "negative": app_data.get("negative", "placeholder"),
                                "estimated_owners": app_data.get("owners", np.nan),
                                "average_playtime_forever": "placeholder",
                                "average_playtime_2weeks": "placeholder",
                                "median_playtime_forever": "placeholder",
                                "median_playtime_2weeks": "placeholder",
                                "peak_ccu": "placeholder",
                                "all_tags": [cat.get("description", "placeholder") for cat in categories],
                                "steam_id": app_id
                            }
                            if pd.isna(parsed_data["estimated_owners"]):
                                parsed_data["estimated_owners"] = 100000
    
                            cleaned_data = self.data_cleaner.clean_data(pd.DataFrame([parsed_data]))
                            if cleaned_data.shape[0] > 0:
                                games_data.append(cleaned_data.to_dict('records')[0])
                        else:
                            print(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –∏–∑ Steam API –∏ Steam Spy API –¥–ª—è app_id: {app_id}. –ù–∞–∑–≤–∞–Ω–∏–µ –∏–≥—Ä—ã: {game.get('name', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')}")
            return games_data
    
        def analyze_single_game(self, game_identifier):
            """–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –æ–¥–∏–Ω–æ—á–Ω—É—é –∏–≥—Ä—É –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏."""
            print(f"üöÄ –ó–∞–ø—É—Å–∫ –∞–Ω–∞–ª–∏–∑–∞ –¥–ª—è –æ–¥–∏–Ω–æ—á–Ω–æ–π –∏–≥—Ä—ã: {game_identifier}")
    
            game_data_list = []
            app_id = None
    
            # –ü–æ–ø—ã—Ç–∫–∞ –∏–∑–≤–ª–µ—á—å appid –∏–∑ —Å—Å—ã–ª–∫–∏, –µ—Å–ª–∏ —ç—Ç–æ —Å—Å—ã–ª–∫–∞
            if 'store.steampowered.com/app/' in game_identifier:
                match = re.search(r'/app/(\d+)', game_identifier)
                if match:
                    app_id = match.group(1)
            elif game_identifier.isdigit():
                app_id = game_identifier
    
            if app_id:
                print(f"üÜî –ò–¥–µ–Ω—Ç–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω App ID: {app_id}")
                game_data_from_dataset, not_found_dataset = self.get_games_data_from_dataset([{'appid': app_id}])
                if game_data_from_dataset:
                    game_data_list = [fg.to_dict() for fg in game_data_from_dataset]
                else:
                    api_game_data = self.get_games_data_from_api([{'appid': app_id}])
                    if api_game_data:
                        game_data_list = api_game_data
                    else:
                        print(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∏–≥—Ä—ã —Å App ID: {app_id}")
                        return None
            else:
                # –ü–æ–∏—Å–∫ –∏–≥—Ä—ã –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é (–º–µ–Ω–µ–µ –Ω–∞–¥–µ–∂–Ω–æ, –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –∏–≥—Ä —Å –ø–æ—Ö–æ–∂–∏–º–∏ –Ω–∞–∑–≤–∞–Ω–∏—è–º–∏)
                print(f"üîç –ü–æ–∏—Å–∫ –∏–≥—Ä—ã –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é: '{game_identifier}'")
                found_games_by_name = self.train_df[self.train_df['name'].str.lower() == game_identifier.lower()]
                if not found_games_by_name.empty:
                    print(f"‚úÖ –ò–≥—Ä–∞ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é –Ω–∞–π–¥–µ–Ω–∞ –≤ –¥–∞—Ç–∞—Å–µ—Ç–µ.")
                    game_data_list = [found_games_by_name.iloc[0].to_dict()] # –ë–µ—Ä–µ–º –ø–µ—Ä–≤—É—é –Ω–∞–π–¥–µ–Ω–Ω—É—é –∏–≥—Ä—É, –µ—Å–ª–∏ –∏—Ö –Ω–µ—Å–∫–æ–ª—å–∫–æ
                    app_id = game_data_list[0].get('steam_id')
                else:
                    print(f"‚ö†Ô∏è –ò–≥—Ä–∞ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ –¥–∞—Ç–∞—Å–µ—Ç–µ. –ü–æ–ø—ã—Ç–∫–∞ –ø–æ–∏—Å–∫–∞ —á–µ—Ä–µ–∑ API (–º–æ–∂–µ—Ç –±—ã—Ç—å –º–µ–¥–ª–µ–Ω–Ω–æ).")
                    # –¢—É—Ç –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ø–æ–∏—Å–∫ —á–µ—Ä–µ–∑ API –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é, –Ω–æ —ç—Ç–æ —Å–ª–æ–∂–Ω–µ–µ –∏ –≤—ã—Ö–æ–¥–∏—Ç –∑–∞ —Ä–∞–º–∫–∏ —Ç–µ–∫—É—â–µ–π –∑–∞–¥–∞—á–∏.
                    print(f"‚ùå –ü–æ–∏—Å–∫ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é —á–µ—Ä–µ–∑ API –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ App ID –∏–ª–∏ —Å—Å—ã–ª–∫—É –Ω–∞ –∏–≥—Ä—É.")
                    return None
    
            if not game_data_list:
                print(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –æ–± –∏–≥—Ä–µ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞: {game_identifier}")
                return None
    
            ranked_game_group = self.calculate_similarity_and_rank(game_data_list, combination_method='average')
            return ranked_game_group
    
    
        def analyze_single_game_for_gradio(self, game_identifier):
            """–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –æ–¥–∏–Ω–æ—á–Ω—É—é –∏–≥—Ä—É –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –≤ —Ç–µ–∫—Å—Ç–æ–≤–æ–º —Ñ–æ—Ä–º–∞—Ç–µ –¥–ª—è Gradio."""
            ranked_game_group = self.analyze_single_game(game_identifier)
            if ranked_game_group:
                recommendations = ranked_game_group.get("recommendations")
                median_similarity = ranked_game_group.get("median_similarity")
                combination_method_name = ranked_game_group.get("combination_method")
    
                output_text = f"üèÜ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –¥–ª—è –∏–≥—Ä—ã '{game_identifier}':\n"
                output_text += f"‚ú® –ú–µ—Ç–æ–¥ –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏—è: {combination_method_name}\n"
                output_text += f"‚≠ê –ú–µ–¥–∏–∞–Ω–∞ similarity score: {median_similarity:.4f}\n"
                output_text += "‚úÖ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:\n"
                for rec in recommendations:
                    output_text += f"  - üéÆ –ù–∞–∑–≤–∞–Ω–∏–µ: {rec['name']}, üë§ –í–ª–∞–¥–µ–ª—å—Ü—ã: {rec['estimated_owners']}, üÜî Steam ID: {rec['steam_id']}, üíØ –°—Ö–æ–∂–µ—Å—Ç—å: {rec['similarity_score']:.4f}\n"
                output_text += "---\n"
                return output_text
            else:
                return "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–π –∏–≥—Ä—ã."
    
    
        def run_analysis_for_gradio(self, steam_user_url):
            """–ó–∞–ø—É—Å–∫–∞–µ—Ç –∞–Ω–∞–ª–∏–∑ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∏–≥—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è Steam –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –≤ —Ç–µ–∫—Å—Ç–æ–≤–æ–º —Ñ–æ—Ä–º–∞—Ç–µ –¥–ª—è Gradio."""
            ranked_games_with_similarity = self.run_analysis_get_results(steam_user_url) # –í—ã–∑—ã–≤–∞–µ–º –Ω–æ–≤—É—é —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
    
            if not ranked_games_with_similarity:
                return "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –¥–ª—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."
    
            output_text = ""
            for group_name in ["recent_games", "most_played_games"]:
                method_results = ranked_games_with_similarity.get(group_name, {})
                if method_results:
                    output_text += f"\n--- üèÜ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –¥–ª—è –≥—Ä—É–ø–ø—ã '{group_name}' ---\n"
                    output_text += f"–ò–≥—Ä—ã –≤ –≥—Ä—É–ø–ø–µ: {[game_item['name'] for game_item in self.all_games_with_data.get(group_name, [])]}\n" # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                    for method, ranked_game_group in method_results.items():
                        recommendations = ranked_game_group.get("recommendations")
                        median_similarity = ranked_game_group.get("median_similarity")
                        combination_method_name = ranked_game_group.get("combination_method")
    
                        output_text += f"\n‚ú® –ú–µ—Ç–æ–¥ –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏—è: {combination_method_name}\n"
                        output_text += f"‚≠ê –ú–µ–¥–∏–∞–Ω–∞ similarity score: {median_similarity:.4f}\n"
                        output_text += "‚úÖ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:\n"
                        for rec in recommendations:
                            output_text += f"  - üéÆ –ù–∞–∑–≤–∞–Ω–∏–µ: {rec['name']}, üë§ –í–ª–∞–¥–µ–ª—å—Ü—ã: {rec['estimated_owners']}, üÜî Steam ID: {rec['steam_id']}, üíØ –°—Ö–æ–∂–µ—Å—Ç—å: {rec['similarity_score']:.4f}\n"
                        output_text += "---\n"
            return output_text
    
    
        def run_analysis_get_results(self, steam_user_url):
            """
            –ó–∞–ø—É—Å–∫–∞–µ—Ç –∞–Ω–∞–ª–∏–∑ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∏–≥—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è Steam –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤ –≤–∏–¥–µ —Å–ª–æ–≤–∞—Ä—è,
            –±–µ–∑ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –≤—ã–≤–æ–¥–∞ –¥–ª—è Gradio.
            """
            print(f"üöÄ –ó–∞–ø—É—Å–∫ –∞–Ω–∞–ª–∏–∑–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å URL: {steam_user_url}")
            # –£–±–∏—Ä–∞–µ–º –ø–æ–≤—Ç–æ—Ä–Ω—ã–π –≤—ã–∑–æ–≤ resolve_vanity_url, –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ URL —É–∂–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π
            # steam_user_id = self.api_parser.resolve_vanity_url(steam_user_url) # –£–î–ê–õ–Ø–ï–ú –≠–¢–£ –°–¢–†–û–ö–£
            steam_user_id_match = re.search(r'/profiles/(\d+)', steam_user_url) # –ü—ã—Ç–∞–µ–º—Å—è –∏–∑–≤–ª–µ—á—å SteamID64 –∏–∑ URL
            if steam_user_id_match:
                steam_user_id = steam_user_id_match.group(1)
            elif steam_user_url.isdigit() and len(steam_user_url) == 17: # –ï—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω SteamID64 –Ω–∞–ø—Ä—è–º—É—é
                steam_user_id = steam_user_url
            elif '/id/' in steam_user_url: # –ï—Å–ª–∏ vanity url, –Ω—É–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å id —á–µ—Ä–µ–∑ API
                vanity_name = steam_user_url.split('/')[-1]
                steam_user_id = self.api_parser.resolve_vanity_url(vanity_name)
            else:
                print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å Steam ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ URL.")
                return None
    
    
            if not steam_user_id:
                print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å Steam ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.")
                return None
            print(f"üë§ –ü–æ–ª—É—á–µ–Ω Steam ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {steam_user_id}")
    
            owned_games = self.api_parser.get_owned_games(steam_user_id)
            if not owned_games:
                print("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∏–≥—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.")
                return None
            print(f"üéÆ –ü–æ–ª—É—á–µ–Ω–æ {len(owned_games)} –∏–≥—Ä –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.")
    
            grouped_games_data = {}
            grouped_games = group_user_games(owned_games)
            print(f"üì¶ –ò–≥—Ä—ã —Å–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞–Ω—ã: {grouped_games.keys()}")
    
            self.all_games_with_data = {} # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –æ –∏–≥—Ä–∞—Ö –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ Gradio output
    
            for group_name in ["recent_games", "most_played_games"]:
                games = grouped_games.get(group_name, [])
                if not games:
                    grouped_games_data[group_name] = []
                    continue
    
                all_games_with_data_for_group = []
    
                print(f"üîç –û–±—Ä–∞–±–æ—Ç–∫–∞ –≥—Ä—É–ø–ø—ã –∏–≥—Ä: {group_name}")
                found_games, not_found_games = self.get_games_data_from_dataset(games)
                print(f"   ‚úÖ –ù–∞–π–¥–µ–Ω–æ –≤ –¥–∞—Ç–∞—Å–µ—Ç–µ: {len(found_games)} –∏–≥—Ä, ‚ö†Ô∏è –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –≤ –¥–∞—Ç–∞—Å–µ—Ç–µ: {len(not_found_games)} –∏–≥—Ä")
                api_games_data = self.get_games_data_from_api(not_found_games)
                print(f"   ‚úÖ –ü–æ–ª—É—á–µ–Ω–æ –∏–∑ API: {len(api_games_data)} –∏–≥—Ä")
    
                found_game_dict_list = [fg.to_dict() if isinstance(fg, pd.Series) else fg for fg in found_games]
                all_games_with_data_for_group = found_game_dict_list + api_games_data
                self.all_games_with_data[group_name] = all_games_with_data_for_group # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç—É—Ç
    
            ranked_games_with_similarity = {}
            combination_methods_to_test = ['average']
    
            for group_name in ["recent_games", "most_played_games"]:
                games_data = self.all_games_with_data.get(group_name, []) # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                if games_data:
                    ranked_games_with_similarity[group_name] = {}
                    for method in combination_methods_to_test:
                        print(f"üìä –†–∞—Å—á–µ—Ç similarity score –¥–ª—è –≥—Ä—É–ø–ø—ã '{group_name}' –º–µ—Ç–æ–¥–æ–º '{method}'")
                        ranked_group_results = self.calculate_similarity_and_rank(games_data, combination_method=method)
                        ranked_games_with_similarity[group_name][method] = ranked_group_results
                else:
                    print(f"‚ÑπÔ∏è –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ–± –∏–≥—Ä–∞—Ö –¥–ª—è –≥—Ä—É–ø–ø—ã '{group_name}'. –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Ä–∞—Å—á–µ—Ç similarity.")
    
            return ranked_games_with_similarity

–ö–ª–∞—Å—Å –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∏–≥—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è Steam –∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π.

–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç LibraryAnalyzer.

### Static methods

` def process_game_name(name) `

     Expand source code
    
    
    def process_game_name(name):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –Ω–∞–∑–≤–∞–Ω–∏–µ –∏–≥—Ä—ã –¥–ª—è —Ü–µ–ª–µ–π —Å—Ä–∞–≤–Ω–µ–Ω–∏—è."""
        if not isinstance(name, str):
            return ""
        name_lower = name.lower()
        name_latin_only = re.sub(r'[^a-z0-9\s]', '', name_lower)
        return name_latin_only

–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –Ω–∞–∑–≤–∞–Ω–∏–µ –∏–≥—Ä—ã –¥–ª—è —Ü–µ–ª–µ–π —Å—Ä–∞–≤–Ω–µ–Ω–∏—è.

### Methods

` def analyze_single_game(self, game_identifier) `

     Expand source code
    
    
    def analyze_single_game(self, game_identifier):
        """–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –æ–¥–∏–Ω–æ—á–Ω—É—é –∏–≥—Ä—É –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏."""
        print(f"üöÄ –ó–∞–ø—É—Å–∫ –∞–Ω–∞–ª–∏–∑–∞ –¥–ª—è –æ–¥–∏–Ω–æ—á–Ω–æ–π –∏–≥—Ä—ã: {game_identifier}")
    
        game_data_list = []
        app_id = None
    
        # –ü–æ–ø—ã—Ç–∫–∞ –∏–∑–≤–ª–µ—á—å appid –∏–∑ —Å—Å—ã–ª–∫–∏, –µ—Å–ª–∏ —ç—Ç–æ —Å—Å—ã–ª–∫–∞
        if 'store.steampowered.com/app/' in game_identifier:
            match = re.search(r'/app/(\d+)', game_identifier)
            if match:
                app_id = match.group(1)
        elif game_identifier.isdigit():
            app_id = game_identifier
    
        if app_id:
            print(f"üÜî –ò–¥–µ–Ω—Ç–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω App ID: {app_id}")
            game_data_from_dataset, not_found_dataset = self.get_games_data_from_dataset([{'appid': app_id}])
            if game_data_from_dataset:
                game_data_list = [fg.to_dict() for fg in game_data_from_dataset]
            else:
                api_game_data = self.get_games_data_from_api([{'appid': app_id}])
                if api_game_data:
                    game_data_list = api_game_data
                else:
                    print(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∏–≥—Ä—ã —Å App ID: {app_id}")
                    return None
        else:
            # –ü–æ–∏—Å–∫ –∏–≥—Ä—ã –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é (–º–µ–Ω–µ–µ –Ω–∞–¥–µ–∂–Ω–æ, –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –∏–≥—Ä —Å –ø–æ—Ö–æ–∂–∏–º–∏ –Ω–∞–∑–≤–∞–Ω–∏—è–º–∏)
            print(f"üîç –ü–æ–∏—Å–∫ –∏–≥—Ä—ã –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é: '{game_identifier}'")
            found_games_by_name = self.train_df[self.train_df['name'].str.lower() == game_identifier.lower()]
            if not found_games_by_name.empty:
                print(f"‚úÖ –ò–≥—Ä–∞ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é –Ω–∞–π–¥–µ–Ω–∞ –≤ –¥–∞—Ç–∞—Å–µ—Ç–µ.")
                game_data_list = [found_games_by_name.iloc[0].to_dict()] # –ë–µ—Ä–µ–º –ø–µ—Ä–≤—É—é –Ω–∞–π–¥–µ–Ω–Ω—É—é –∏–≥—Ä—É, –µ—Å–ª–∏ –∏—Ö –Ω–µ—Å–∫–æ–ª—å–∫–æ
                app_id = game_data_list[0].get('steam_id')
            else:
                print(f"‚ö†Ô∏è –ò–≥—Ä–∞ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ –¥–∞—Ç–∞—Å–µ—Ç–µ. –ü–æ–ø—ã—Ç–∫–∞ –ø–æ–∏—Å–∫–∞ —á–µ—Ä–µ–∑ API (–º–æ–∂–µ—Ç –±—ã—Ç—å –º–µ–¥–ª–µ–Ω–Ω–æ).")
                # –¢—É—Ç –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ø–æ–∏—Å–∫ —á–µ—Ä–µ–∑ API –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é, –Ω–æ —ç—Ç–æ —Å–ª–æ–∂–Ω–µ–µ –∏ –≤—ã—Ö–æ–¥–∏—Ç –∑–∞ —Ä–∞–º–∫–∏ —Ç–µ–∫—É—â–µ–π –∑–∞–¥–∞—á–∏.
                print(f"‚ùå –ü–æ–∏—Å–∫ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é —á–µ—Ä–µ–∑ API –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ App ID –∏–ª–∏ —Å—Å—ã–ª–∫—É –Ω–∞ –∏–≥—Ä—É.")
                return None
    
        if not game_data_list:
            print(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –æ–± –∏–≥—Ä–µ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞: {game_identifier}")
            return None
    
        ranked_game_group = self.calculate_similarity_and_rank(game_data_list, combination_method='average')
        return ranked_game_group

–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –æ–¥–∏–Ω–æ—á–Ω—É—é –∏–≥—Ä—É –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏.

` def analyze_single_game_for_gradio(self, game_identifier) `

     Expand source code
    
    
    def analyze_single_game_for_gradio(self, game_identifier):
        """–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –æ–¥–∏–Ω–æ—á–Ω—É—é –∏–≥—Ä—É –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –≤ —Ç–µ–∫—Å—Ç–æ–≤–æ–º —Ñ–æ—Ä–º–∞—Ç–µ –¥–ª—è Gradio."""
        ranked_game_group = self.analyze_single_game(game_identifier)
        if ranked_game_group:
            recommendations = ranked_game_group.get("recommendations")
            median_similarity = ranked_game_group.get("median_similarity")
            combination_method_name = ranked_game_group.get("combination_method")
    
            output_text = f"üèÜ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –¥–ª—è –∏–≥—Ä—ã '{game_identifier}':\n"
            output_text += f"‚ú® –ú–µ—Ç–æ–¥ –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏—è: {combination_method_name}\n"
            output_text += f"‚≠ê –ú–µ–¥–∏–∞–Ω–∞ similarity score: {median_similarity:.4f}\n"
            output_text += "‚úÖ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:\n"
            for rec in recommendations:
                output_text += f"  - üéÆ –ù–∞–∑–≤–∞–Ω–∏–µ: {rec['name']}, üë§ –í–ª–∞–¥–µ–ª—å—Ü—ã: {rec['estimated_owners']}, üÜî Steam ID: {rec['steam_id']}, üíØ –°—Ö–æ–∂–µ—Å—Ç—å: {rec['similarity_score']:.4f}\n"
            output_text += "---\n"
            return output_text
        else:
            return "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–π –∏–≥—Ä—ã."

–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –æ–¥–∏–Ω–æ—á–Ω—É—é –∏–≥—Ä—É –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –≤ —Ç–µ–∫—Å—Ç–æ–≤–æ–º —Ñ–æ—Ä–º–∞—Ç–µ –¥–ª—è
Gradio.

` def calculate_similarity_and_rank(self, games_data,
combination_method='average') `

     Expand source code
    
    
    def calculate_similarity_and_rank(self, games_data, combination_method='average'):
        """–í—ã—á–∏—Å–ª—è–µ—Ç –∫–æ—Å–∏–Ω—É—Å–Ω—É—é —Å—Ö–æ–∂–µ—Å—Ç—å –∏ —Ä–∞–Ω–∂–∏—Ä—É–µ—Ç –∏–≥—Ä—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –≤–µ–∫—Ç–æ—Ä–æ–≤."""
        if not games_data:
            return []
    
        print(f"\n--- ‚öôÔ∏è –ú–µ—Ç–æ–¥ calculate_similarity_and_rank: {combination_method} ---")
    
        train_vectors = self.model.transform(self.train_df)
    
        new_df = pd.DataFrame(games_data)
        new_df['short_description_clean'] = new_df['short_description'].apply(clean_text)
        new_df['steam_id'] = [game.get('appid') for game in games_data]
    
        game_vectors = self.model.transform(new_df)
    
        if combination_method == 'average':
            combined_game_vector = np.mean(game_vectors, axis=0).reshape(1, -1)
            method_name = "–û–±—ã—á–Ω–æ–µ —É—Å—Ä–µ–¥–Ω–µ–Ω–∏–µ –≤–µ–∫—Ç–æ—Ä–æ–≤"
        elif combination_method == 'sum':
            combined_game_vector = np.sum(game_vectors, axis=0).reshape(1, -1)
            method_name = "–û–±—ã—á–Ω–æ–µ —Å—É–º–º–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–µ–∫—Ç–æ—Ä–æ–≤"
        else:
            raise ValueError(f"‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –º–µ—Ç–æ–¥ –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏—è: {combination_method}")
    
        similarities = cosine_similarity(combined_game_vector, train_vectors)
        game_similarities = similarities[0]
        ranked_indices = np.argsort(game_similarities)[::-1]
    
        game_recommendations = []
    
        input_game_names_processed = {process_game_name(game_data.get('name')) for game_data in games_data if 'name' in game_data}
        print(f"üêû input_game_names_processed: {input_game_names_processed}")
    
        for j in ranked_indices:
            recommended_game = self.train_df.iloc[j]
            recommended_game_name = recommended_game['name']
            recommended_game_name_processed = process_game_name(recommended_game_name)
    
            print(f"ü§î –†–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–µ–º —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—é: –ù–∞–∑–≤–∞–Ω–∏–µ: {recommended_game_name}, Processed Name: {recommended_game_name_processed}")
    
            if recommended_game_name_processed in input_game_names_processed:
                print(f"üö´ –ò—Å–∫–ª—é—á–µ–Ω–∞ –∏–≥—Ä–∞: {recommended_game_name} (processed name: {recommended_game_name_processed}) —Ç–∞–∫ –∫–∞–∫ –æ–Ω–∞ –µ—Å—Ç—å –≤–æ –≤—Ö–æ–¥–Ω–æ–π –≥—Ä—É–ø–ø–µ.")
                continue
            else:
                print(f"üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–º–µ–Ω–∏: '{recommended_game_name_processed}' –Ω–µ –≤ '{input_game_names_processed}' - –∏–≥—Ä–∞ –ù–ï –∏–∑ –≤—Ö–æ–¥–Ω–æ–π –≥—Ä—É–ø–ø—ã.")
    
            estimated_owners = recommended_game['estimated_owners']
            positive = recommended_game['positive']
            negative = recommended_game['negative']
    
            if estimated_owners == 0:
                print(f"üö´ –ò—Å–∫–ª—é—á–µ–Ω–∞ –∏–≥—Ä–∞: {recommended_game_name} (steam_id: {recommended_game.name}) –∏–∑-–∑–∞ estimated_owners == 0.")
                continue
    
            if isinstance(positive, (int, float)) and isinstance(negative, (int, float)):
                total_reviews = positive + negative
                if total_reviews > 0:
                    positive_ratio = positive / total_reviews
                    if positive_ratio < 0.7:
                        print(f"üö´ –ò—Å–∫–ª—é—á–µ–Ω–∞ –∏–≥—Ä–∞: {recommended_game_name} (steam_id: {recommended_game.name}) –∏–∑-–∑–∞ positive_ratio < 0.7 ({positive_ratio:.2f}).")
                        continue
    
            if len(game_recommendations) < 10:
                game_recommendations.append(
                    {
                        "name": recommended_game_name,
                        "estimated_owners": estimated_owners,
                        "steam_id": recommended_game.name,
                        "similarity_score": game_similarities[j]
                    }
                )
            if len(game_recommendations) >= 10:
                break
    
        scores = [d['similarity_score'] for d in game_recommendations]
        median_similarity = np.median(scores) if scores else 0
    
        ranked_game_group = {
            "game_data": {"name": f"–ì—Ä—É–ø–ø–∞ –∏–≥—Ä ({method_name})", "appid": f"group_{combination_method}"},
            "recommendations": game_recommendations,
            "median_similarity": median_similarity,
            "combination_method": method_name
        }
        return ranked_game_group

–í—ã—á–∏—Å–ª—è–µ—Ç –∫–æ—Å–∏–Ω—É—Å–Ω—É—é —Å—Ö–æ–∂–µ—Å—Ç—å –∏ —Ä–∞–Ω–∂–∏—Ä—É–µ—Ç –∏–≥—Ä—ã –Ω–∞ –æ—Å–Ω–æ–≤–µ –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö
–≤–µ–∫—Ç–æ—Ä–æ–≤.

` def get_games_data_from_api(self, not_found_games) `

     Expand source code
    
    
    def get_games_data_from_api(self, not_found_games):
        """–ü–æ–ª—É—á–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –æ–± –∏–≥—Ä–∞—Ö –∏–∑ Steam API –∏ Steam Spy API."""
        games_data = []
        if not not_found_games:
            return games_data
        for game in not_found_games:
            app_id = game.get('appid')
            if app_id:
                steam_web_api_response = self.api_parser.steam_web_api_client.make_request(
                    request_name="get_app_details",
                    request_params={"appids": app_id}
                )
    
                app_data = None
                if steam_web_api_response['error'] is None and steam_web_api_response['response_json']:
                    app_data = steam_web_api_response['response_json'].get(str(app_id), {}).get('data')
    
                if app_data:
                    categories = app_data.get("categories", [])
                    if not isinstance(categories, list):
                        categories = []
                    parsed_data = {
                        "name": app_data.get("name", "placeholder"),
                        "release_date": app_data.get("release_date", {}).get("date", "placeholder"),
                        "required_age": app_data.get("required_age", "placeholder"),
                        "price": app_data.get("price_overview", {}).get("final_formatted", "placeholder"),
                        "dlc_count": len(app_data.get("dlc", [])) if isinstance(app_data.get("dlc"), list) else 0,
                        "detailed_description": app_data.get("detailed_description", "placeholder"),
                        "about_the_game": app_data.get("about_the_game", "placeholder"),
                        "short_description": app_data.get("short_description", "placeholder"),
                        "reviews": app_data.get("reviews", "placeholder"),
                        "header_image": app_data.get("header_image", "placeholder"),
                        "website": app_data.get("website", "placeholder"),
                        "support_url": app_data.get("support_info", {}).get("url", "placeholder"),
                        "support_email": app_data.get("support_info", {}).get("email", "placeholder"),
                        "windows": app_data.get("platforms", {}).get("windows", "placeholder"),
                        "mac": app_data.get("platforms", {}).get("mac", "placeholder"),
                        "linux": app_data.get("platforms", {}).get("linux", "placeholder"),
                        "metacritic_score": app_data.get("metacritic", {}).get("score", "placeholder"),
                        "metacritic_url": app_data.get("metacritic", {}).get("url", "placeholder"),
                        "achievements": app_data.get("achievements", {}).get("total", "placeholder"),
                        "recommendations": app_data.get("recommendations", {}).get("total", "placeholder"),
                        "notes": "placeholder",
                        "supported_languages": app_data.get("supported_languages", "placeholder"),
                        "full_audio_languages": app_data.get("full_audio_languages", "placeholder"),
                        "packages": app_data.get("packages", "placeholder"),
                        "developers": app_data.get("developers", "placeholder"),
                        "publishers": app_data.get("publishers", "placeholder"),
                        "categories": [cat.get("description", "placeholder") for cat in categories],
                        "genres": [genre.get("description", "placeholder") for genre in app_data.get("genres", [])],
                        "screenshots": [ss.get("path_thumbnail", "placeholder") for ss in app_data.get("screenshots", [])],
                        "movies": [m.get("webm", {}).get("480", "placeholder") for m in app_data.get("movies", [])],
                        "user_score": "placeholder",
                        "score_rank": "placeholder",
                        "positive": "placeholder",
                        "negative": "placeholder",
                        "estimated_owners": app_data.get("estimated_owners", np.nan),
                        "average_playtime_forever": "placeholder",
                        "average_playtime_2weeks": "placeholder",
                        "median_playtime_forever": "placeholder",
                        "median_playtime_2weeks": "placeholder",
                        "peak_ccu": "placeholder",
                        "all_tags": [cat.get("description", "placeholder") for cat in categories],
                        "steam_id": app_id
                    }
                    if pd.isna(parsed_data["estimated_owners"]):
                        parsed_data["estimated_owners"] = 100000
    
                    cleaned_data = self.data_cleaner.clean_data(pd.DataFrame([parsed_data]))
                    if cleaned_data.shape[0] > 0:
                        games_data.append(cleaned_data.to_dict('records')[0])
                else:
                    steamspy_api_response = self.api_parser.steamspy_api_client.make_request(
                        request_name="get_app_details",
                        request_params={"appid": app_id}
                    )
                    if steamspy_api_response['error'] is None and steamspy_api_response['response_json']:
                        app_data = steamspy_api_response['response_json']
                        categories = app_data.get("categories", [])
                        if not isinstance(categories, list):
                            categories = []
    
                        parsed_data = {
                            "name": app_data.get("name", "placeholder"),
                            "release_date": "placeholder",
                            "required_age": "placeholder",
                            "price": "placeholder",
                            "dlc_count": "placeholder",
                            "detailed_description": "placeholder",
                            "about_the_game": "placeholder",
                            "short_description": "placeholder",
                            "reviews": "placeholder",
                            "header_image": "placeholder",
                            "website": "placeholder",
                            "support_url": "placeholder",
                            "support_email": "placeholder",
                            "windows": "placeholder",
                            "mac": "placeholder",
                            "linux": "placeholder",
                            "metacritic_score": app_data.get("metacritic", "placeholder"),
                            "metacritic_url": "placeholder",
                            "achievements": "placeholder",
                            "recommendations": "placeholder",
                            "notes": "placeholder",
                            "supported_languages": "placeholder",
                            "full_audio_languages": "placeholder",
                            "packages": "placeholder",
                            "developers": "placeholder",
                            "publishers": "placeholder",
                            "categories": "placeholder",
                            "genres": "placeholder",
                            "screenshots": "placeholder",
                            "movies": "placeholder",
                            "user_score": "placeholder",
                            "score_rank": "placeholder",
                            "positive": app_data.get("positive", "placeholder"),
                            "negative": app_data.get("negative", "placeholder"),
                            "estimated_owners": app_data.get("owners", np.nan),
                            "average_playtime_forever": "placeholder",
                            "average_playtime_2weeks": "placeholder",
                            "median_playtime_forever": "placeholder",
                            "median_playtime_2weeks": "placeholder",
                            "peak_ccu": "placeholder",
                            "all_tags": [cat.get("description", "placeholder") for cat in categories],
                            "steam_id": app_id
                        }
                        if pd.isna(parsed_data["estimated_owners"]):
                            parsed_data["estimated_owners"] = 100000
    
                        cleaned_data = self.data_cleaner.clean_data(pd.DataFrame([parsed_data]))
                        if cleaned_data.shape[0] > 0:
                            games_data.append(cleaned_data.to_dict('records')[0])
                    else:
                        print(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –∏–∑ Steam API –∏ Steam Spy API –¥–ª—è app_id: {app_id}. –ù–∞–∑–≤–∞–Ω–∏–µ –∏–≥—Ä—ã: {game.get('name', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')}")
        return games_data

–ü–æ–ª—É—á–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –æ–± –∏–≥—Ä–∞—Ö –∏–∑ Steam API –∏ Steam Spy API.

` def get_games_data_from_dataset(self, games) `

     Expand source code
    
    
    def get_games_data_from_dataset(self, games):
        """–ò–∑–≤–ª–µ–∫–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –æ–± –∏–≥—Ä–∞—Ö –∏–∑ –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–≥–æ –¥–∞—Ç–∞—Å–µ—Ç–∞."""
        found_games = []
        not_found_games = []
        for game in games:
            app_id = game.get("appid")
            if app_id is not None and app_id in self.train_df.index:
              found_games.append(self.train_df.loc[app_id])
            else:
                not_found_games.append(game)
        return found_games, not_found_games

–ò–∑–≤–ª–µ–∫–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –æ–± –∏–≥—Ä–∞—Ö –∏–∑ –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–≥–æ –¥–∞—Ç–∞—Å–µ—Ç–∞.

` def run_analysis_for_gradio(self, steam_user_url) `

     Expand source code
    
    
    def run_analysis_for_gradio(self, steam_user_url):
        """–ó–∞–ø—É—Å–∫–∞–µ—Ç –∞–Ω–∞–ª–∏–∑ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∏–≥—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è Steam –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –≤ —Ç–µ–∫—Å—Ç–æ–≤–æ–º —Ñ–æ—Ä–º–∞—Ç–µ –¥–ª—è Gradio."""
        ranked_games_with_similarity = self.run_analysis_get_results(steam_user_url) # –í—ã–∑—ã–≤–∞–µ–º –Ω–æ–≤—É—é —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
    
        if not ranked_games_with_similarity:
            return "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –¥–ª—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è."
    
        output_text = ""
        for group_name in ["recent_games", "most_played_games"]:
            method_results = ranked_games_with_similarity.get(group_name, {})
            if method_results:
                output_text += f"\n--- üèÜ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –¥–ª—è –≥—Ä—É–ø–ø—ã '{group_name}' ---\n"
                output_text += f"–ò–≥—Ä—ã –≤ –≥—Ä—É–ø–ø–µ: {[game_item['name'] for game_item in self.all_games_with_data.get(group_name, [])]}\n" # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                for method, ranked_game_group in method_results.items():
                    recommendations = ranked_game_group.get("recommendations")
                    median_similarity = ranked_game_group.get("median_similarity")
                    combination_method_name = ranked_game_group.get("combination_method")
    
                    output_text += f"\n‚ú® –ú–µ—Ç–æ–¥ –∫–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏—è: {combination_method_name}\n"
                    output_text += f"‚≠ê –ú–µ–¥–∏–∞–Ω–∞ similarity score: {median_similarity:.4f}\n"
                    output_text += "‚úÖ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:\n"
                    for rec in recommendations:
                        output_text += f"  - üéÆ –ù–∞–∑–≤–∞–Ω–∏–µ: {rec['name']}, üë§ –í–ª–∞–¥–µ–ª—å—Ü—ã: {rec['estimated_owners']}, üÜî Steam ID: {rec['steam_id']}, üíØ –°—Ö–æ–∂–µ—Å—Ç—å: {rec['similarity_score']:.4f}\n"
                    output_text += "---\n"
        return output_text

–ó–∞–ø—É—Å–∫–∞–µ—Ç –∞–Ω–∞–ª–∏–∑ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∏–≥—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è Steam –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –≤
—Ç–µ–∫—Å—Ç–æ–≤–æ–º —Ñ–æ—Ä–º–∞—Ç–µ –¥–ª—è Gradio.

` def run_analysis_get_results(self, steam_user_url) `

     Expand source code
    
    
    def run_analysis_get_results(self, steam_user_url):
        """
        –ó–∞–ø—É—Å–∫–∞–µ—Ç –∞–Ω–∞–ª–∏–∑ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∏–≥—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è Steam –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤ –≤–∏–¥–µ —Å–ª–æ–≤–∞—Ä—è,
        –±–µ–∑ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –≤—ã–≤–æ–¥–∞ –¥–ª—è Gradio.
        """
        print(f"üöÄ –ó–∞–ø—É—Å–∫ –∞–Ω–∞–ª–∏–∑–∞ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å URL: {steam_user_url}")
        # –£–±–∏—Ä–∞–µ–º –ø–æ–≤—Ç–æ—Ä–Ω—ã–π –≤—ã–∑–æ–≤ resolve_vanity_url, –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ URL —É–∂–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π
        # steam_user_id = self.api_parser.resolve_vanity_url(steam_user_url) # –£–î–ê–õ–Ø–ï–ú –≠–¢–£ –°–¢–†–û–ö–£
        steam_user_id_match = re.search(r'/profiles/(\d+)', steam_user_url) # –ü—ã—Ç–∞–µ–º—Å—è –∏–∑–≤–ª–µ—á—å SteamID64 –∏–∑ URL
        if steam_user_id_match:
            steam_user_id = steam_user_id_match.group(1)
        elif steam_user_url.isdigit() and len(steam_user_url) == 17: # –ï—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω SteamID64 –Ω–∞–ø—Ä—è–º—É—é
            steam_user_id = steam_user_url
        elif '/id/' in steam_user_url: # –ï—Å–ª–∏ vanity url, –Ω—É–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å id —á–µ—Ä–µ–∑ API
            vanity_name = steam_user_url.split('/')[-1]
            steam_user_id = self.api_parser.resolve_vanity_url(vanity_name)
        else:
            print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å Steam ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–∑ URL.")
            return None
    
    
        if not steam_user_id:
            print("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å Steam ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.")
            return None
        print(f"üë§ –ü–æ–ª—É—á–µ–Ω Steam ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {steam_user_id}")
    
        owned_games = self.api_parser.get_owned_games(steam_user_id)
        if not owned_games:
            print("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∏–≥—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.")
            return None
        print(f"üéÆ –ü–æ–ª—É—á–µ–Ω–æ {len(owned_games)} –∏–≥—Ä –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.")
    
        grouped_games_data = {}
        grouped_games = group_user_games(owned_games)
        print(f"üì¶ –ò–≥—Ä—ã —Å–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞–Ω—ã: {grouped_games.keys()}")
    
        self.all_games_with_data = {} # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –æ –∏–≥—Ä–∞—Ö –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ Gradio output
    
        for group_name in ["recent_games", "most_played_games"]:
            games = grouped_games.get(group_name, [])
            if not games:
                grouped_games_data[group_name] = []
                continue
    
            all_games_with_data_for_group = []
    
            print(f"üîç –û–±—Ä–∞–±–æ—Ç–∫–∞ –≥—Ä—É–ø–ø—ã –∏–≥—Ä: {group_name}")
            found_games, not_found_games = self.get_games_data_from_dataset(games)
            print(f"   ‚úÖ –ù–∞–π–¥–µ–Ω–æ –≤ –¥–∞—Ç–∞—Å–µ—Ç–µ: {len(found_games)} –∏–≥—Ä, ‚ö†Ô∏è –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –≤ –¥–∞—Ç–∞—Å–µ—Ç–µ: {len(not_found_games)} –∏–≥—Ä")
            api_games_data = self.get_games_data_from_api(not_found_games)
            print(f"   ‚úÖ –ü–æ–ª—É—á–µ–Ω–æ –∏–∑ API: {len(api_games_data)} –∏–≥—Ä")
    
            found_game_dict_list = [fg.to_dict() if isinstance(fg, pd.Series) else fg for fg in found_games]
            all_games_with_data_for_group = found_game_dict_list + api_games_data
            self.all_games_with_data[group_name] = all_games_with_data_for_group # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç—É—Ç
    
        ranked_games_with_similarity = {}
        combination_methods_to_test = ['average']
    
        for group_name in ["recent_games", "most_played_games"]:
            games_data = self.all_games_with_data.get(group_name, []) # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
            if games_data:
                ranked_games_with_similarity[group_name] = {}
                for method in combination_methods_to_test:
                    print(f"üìä –†–∞—Å—á–µ—Ç similarity score –¥–ª—è –≥—Ä—É–ø–ø—ã '{group_name}' –º–µ—Ç–æ–¥–æ–º '{method}'")
                    ranked_group_results = self.calculate_similarity_and_rank(games_data, combination_method=method)
                    ranked_games_with_similarity[group_name][method] = ranked_group_results
            else:
                print(f"‚ÑπÔ∏è –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ–± –∏–≥—Ä–∞—Ö –¥–ª—è –≥—Ä—É–ø–ø—ã '{group_name}'. –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Ä–∞—Å—á–µ—Ç similarity.")
    
        return ranked_games_with_similarity

–ó–∞–ø—É—Å–∫–∞–µ—Ç –∞–Ω–∞–ª–∏–∑ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –∏–≥—Ä –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è Steam –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤
–≤–∏–¥–µ —Å–ª–æ–≤–∞—Ä—è, –±–µ–∑ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –≤—ã–≤–æ–¥–∞ –¥–ª—è Gradio.

  * ### Super-module

    * `[src](index.html "src")`
  * ### Functions

    * `calculate_similarity_and_rank`
    * `load_dataframe`
    * `load_model`
    * `main`
    * `process_game_name`
  * ### Classes

    * #### `LibraryAnalyzer`

      * `analyze_single_game`
      * `analyze_single_game_for_gradio`
      * `calculate_similarity_and_rank`
      * `get_games_data_from_api`
      * `get_games_data_from_dataset`
      * `process_game_name`
      * `run_analysis_for_gradio`
      * `run_analysis_get_results`

Generated by [pdoc 0.11.5](https://pdoc3.github.io/pdoc "pdoc: Python API
documentation generator").

